# ********RoostGPT********
"""
Test generated by RoostGPT for test python-test using AI Type  and AI Model 

ROOST_METHOD_HASH=bin_to_decimal_a60af02cc6
ROOST_METHOD_SIG_HASH=bin_to_decimal_68e51ce41d


### Test Scenarios for `bin_to_decimal` Function

**Scenario 1: Convert a simple binary string to a decimal number**  
Details:  
  TestName: test_simple_binary_to_decimal_conversion  
  Description: This test verifies that the function correctly converts a straightforward binary string without any additional spaces or special characters to its decimal equivalent.  
Execution:  
  Arrange: Prepare a binary string '1101'.  
  Act: Call bin_to_decimal('1101').  
  Assert: The output should be 13.  
Validation:  
  This test ensures that the function handles basic binary-to-decimal conversion, which is the core functionality of the function. Ensuring this works correctly is essential for the reliability of the function.

**Scenario 2: Handle binary strings with leading and trailing spaces**  
Details:  
  TestName: test_binary_string_with_spaces  
  Description: This test checks if the function can handle binary strings that contain leading and trailing spaces and still perform the correct conversion.  
Execution:  
  Arrange: Prepare a binary string '   1011   '.  
  Act: Call bin_to_decimal('   1011   ').  
  Assert: The output should be 11.  
Validation:  
  This test verifies that the function's use of `.strip()` effectively removes unnecessary spaces, allowing for user input variability. This is crucial for user flexibility and input robustness.

**Scenario 3: Convert a negative binary string to a decimal number**  
Details:  
  TestName: test_negative_binary_to_decimal_conversion  
  Description: This test ensures that the function correctly interprets and converts a binary string representing a negative binary number.  
Execution:  
  Arrange: Prepare a binary string '-1001'.  
  Act: Call bin_to_decimal('-1001').  
  Assert: The output should be -9.  
Validation:  
  This test is important for confirming that the function can handle binary numbers with negative signs, which expands its utility to include negative numbers, reflecting a comprehensive understanding of binary notation.

**Scenario 4: Pass a non-binary string and expect a ValueError**  
Details:  
  TestName: test_non_binary_input_raises_error  
  Description: This test checks that the function raises a ValueError when passed a string containing characters other than '0', '1', or a leading '-'.  
Execution:  
  Arrange: Prepare a string '102'.  
  Act: Attempt to call bin_to_decimal('102').  
  Assert: A ValueError is expected with the message "Non-binary value was passed to the function".  
Validation:  
  This test ensures that the function is protected against invalid input, which helps maintain data integrity and provides clear feedback to the user about input mistakes.

**Scenario 5: Pass an empty string and expect a ValueError**  
Details:  
  TestName: test_empty_string_raises_error  
  Description: This test verifies that passing an empty string to the function raises a ValueError indicating that the input was empty.  
Execution:  
  Arrange: Prepare an empty string ''.  
  Act: Attempt to call bin_to_decimal('').  
  Assert: A ValueError is expected with the message "Empty string was passed to the function".  
Validation:  
  Testing the function's response to an empty input ensures that it can gracefully handle such cases by informing the user, rather than failing silently or throwing a less informative error.

These scenarios collectively ensure that `bin_to_decimal` functions correctly across a range of typical use cases and edge cases, maintaining reliability and robustness in diverse situations.
"""

# ********RoostGPT********
import pytest
from conversions.binary_to_decimal import bin_to_decimal

class Test_BinaryToDecimalBinToDecimal:
    
    @pytest.mark.valid
    def test_simple_binary_to_decimal_conversion(self):
        # Arrange
        binary_string = '1101'
        expected_decimal = 13
        # Act
        result = bin_to_decimal(binary_string)
        # Assert
        assert result == expected_decimal, f"Expected {expected_decimal}, got {result}"

    @pytest.mark.valid
    def test_binary_string_with_spaces(self):
        # Arrange
        binary_string = '   1011   '
        expected_decimal = 11
        # Act
        result = bin_to_decimal(binary_string)
        # Assert
        assert result == expected_decimal, f"Expected {expected_decimal}, got {result}"

    @pytest.mark.negative
    def test_negative_binary_to_decimal_conversion(self):
        # Arrange
        binary_string = '-1001'
        expected_decimal = -9
        # Act
        result = bin_to_decimal(binary_string)
        # Assert
        assert result == expected_decimal, f"Expected {expected_decimal}, got {result}"

    @pytest.mark.invalid
    def test_non_binary_input_raises_error(self):
        # Arrange
        non_binary_string = '102'
        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            bin_to_decimal(non_binary_string)
        assert str(exc_info.value) == "Non-binary value was passed to the function"

    @pytest.mark.invalid
    def test_empty_string_raises_error(self):
        # Arrange
        empty_string = ''
        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            bin_to_decimal(empty_string)
        assert str(exc_info.value) == "Empty string was passed to the function"

if __name__ == '__main__':
    from doctest import testmod
    testmod()
